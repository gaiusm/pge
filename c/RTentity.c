/* do not edit automatically generated by mc from RTentity.  */
/* RTentity.mod implements a grouping of different opaque types.

Copyright (C) 2008-2020 Free Software Foundation, Inc.
Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.

This file is part of GNU Modula-2.

GNU Modula-2 is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GNU Modula-2 is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

#   if !defined (PROC_D)
#      define PROC_D
       typedef void (*PROC_t) (void);
       typedef struct { PROC_t proc; } PROC;
#   endif

#   if !defined (TRUE)
#      define TRUE (1==1)
#   endif

#   if !defined (FALSE)
#      define FALSE (1==0)
#   endif

#include <stddef.h>
#include <stdlib.h>
#define _RTentity_H
#define _RTentity_C

#   include "Glibc.h"
#   include "GM2RTS.h"
#   include "GRTco.h"

typedef struct _T1_r _T1;

typedef _T1 *RTentity_Group;

struct _T1_r {
               RTentity_Group left;
               RTentity_Group right;
               void *entity;
               unsigned int entityKey;
             };

static unsigned int initialized;
static int mutex;
RTentity_Group RTentity_InitGroup (void);

/*
   killGroup -
*/

RTentity_Group RTentity_KillGroup (RTentity_Group g);

/*
   killGroup -
*/

unsigned int RTentity_GetKey (RTentity_Group g, void * a);

/*
   killGroup -
*/

void RTentity_PutKey (RTentity_Group g, void * a, unsigned int key);

/*
   DelKey - deletes an entry in the binary tree.

            NB in order for this to work we must
            ensure that the InitGroup sets
            both left and right to NIL.
*/

void RTentity_DelKey (RTentity_Group g, void * a);
unsigned int RTentity_IsIn (RTentity_Group g, void * a);

/*
   killGroup -
*/

static RTentity_Group killGroup (RTentity_Group g);

/*
   findChildAndParent - find a node, child, in a binary tree, t, with name
                        equal to n.  If an entry is found, parent is set
                        to the node above child.
*/

static void findChildAndParent (RTentity_Group t, void * a, RTentity_Group *child, RTentity_Group *parent);

/*
   checkInitialised -
*/

static void checkInitialised (void);


/*
   killGroup -
*/

static RTentity_Group killGroup (RTentity_Group g)
{
  if (g != NULL)
    {
      g->left = killGroup (g->left);
      g->right = killGroup (g->right);
      libc_free ((void *) g);
    }
  return NULL;
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   findChildAndParent - find a node, child, in a binary tree, t, with name
                        equal to n.  If an entry is found, parent is set
                        to the node above child.
*/

static void findChildAndParent (RTentity_Group t, void * a, RTentity_Group *child, RTentity_Group *parent)
{
  /* remember to skip the sentinal value and assign parent and child  */
  (*parent) = t;
  if (t == NULL)
    {
      M2RTS_Halt ((char *) "/home/gaius/GM2/graft-combine/gm2-floppsie/gcc/m2/gm2-libs-iso/RTentity.mod", 75, 240, (char *) "findChildAndParent", 18, (char *) "internal runtime error, RTentity is either corrupt or the module storage has not been initialized yet", 101);
    }
  (*child) = t->left;
  if ((*child) != NULL)
    {
      do {
        if (a < (*child)->entity)
          {
            (*parent) = (*child);
            (*child) = (*child)->left;
          }
        else if (a > (*child)->entity)
          {
            /* avoid dangling else.  */
            (*parent) = (*child);
            (*child) = (*child)->right;
          }
      } while (! (((*child) == NULL) || (a == (*child)->entity)));
    }
}


/*
   checkInitialised -
*/

static void checkInitialised (void)
{
  int result;

  if (! initialized)
    {
      initialized = TRUE;
      result = RTco_init ();
      mutex = RTco_initSemaphore (1);
    }
}

RTentity_Group RTentity_InitGroup (void)
{
  RTentity_Group g;

  checkInitialised ();
  RTco_wait (mutex);
  g = libc_malloc ((size_t) sizeof ((*g)));
  g->left = NULL;
  g->right = NULL;
  g->entity = NULL;
  g->entityKey = 0;
  RTco_signal (mutex);
  return g;
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   killGroup -
*/

RTentity_Group RTentity_KillGroup (RTentity_Group g)
{
  RTco_wait (mutex);
  g = killGroup (g);
  RTco_signal (mutex);
  return g;
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   killGroup -
*/

unsigned int RTentity_GetKey (RTentity_Group g, void * a)
{
  RTentity_Group parent;
  RTentity_Group child;

  RTco_wait (mutex);
  findChildAndParent (g, a, &child, &parent);
  RTco_signal (mutex);
  if (child == NULL)
    {
      return 0;
    }
  else
    {
      return child->entityKey;
    }
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   killGroup -
*/

void RTentity_PutKey (RTentity_Group g, void * a, unsigned int key)
{
  RTentity_Group parent;
  RTentity_Group child;

  RTco_wait (mutex);
  findChildAndParent (g, a, &child, &parent);
  if (child == NULL)
    {
      /* no child found, now is, a, less than parent or greater?  */
      if (parent == g)
        {
          /* empty tree, add it to the left branch of t  */
          child = libc_malloc ((size_t) sizeof ((*child)));
          parent->left = child;
        }
      else
        {
          /* parent is a leaf node  */
          if (a < parent->entity)
            {
              child = libc_malloc ((size_t) sizeof ((*child)));
              parent->left = child;
            }
          else if (a > parent->entity)
            {
              /* avoid dangling else.  */
              child = libc_malloc ((size_t) sizeof ((*child)));
              parent->right = child;
            }
        }
      child->right = NULL;
      child->left = NULL;
      child->entity = a;
      child->entityKey = key;
    }
  else
    {
      M2RTS_Halt ((char *) "/home/gaius/GM2/graft-combine/gm2-floppsie/gcc/m2/gm2-libs-iso/RTentity.mod", 75, 138, (char *) "PutKey", 6, (char *) "internal runtime error, entity already stored", 45);
    }
  RTco_signal (mutex);
}


/*
   DelKey - deletes an entry in the binary tree.

            NB in order for this to work we must
            ensure that the InitGroup sets
            both left and right to NIL.
*/

void RTentity_DelKey (RTentity_Group g, void * a)
{
  RTentity_Group i;
  RTentity_Group child;
  RTentity_Group parent;

  RTco_wait (mutex);
  /* find parent and child of the node  */
  findChildAndParent (g, a, &child, &parent);
  if ((child != NULL) && (child->entity == a))
    {
      /* Have found the node to be deleted  */
      if (parent->right == child)
        {
          /* most branch of child^.left.  */
          if (child->left != NULL)
            {
              /* Scan for right most node of child^.left  */
              i = child->left;
              while (i->right != NULL)
                {
                  i = i->right;
                }
              i->right = child->right;
              parent->right = child->left;
            }
          else
            {
              /* (as in a single linked list) to child^.right  */
              parent->right = child->right;
            }
          libc_free ((void *) child);
        }
      else
        {
          /* branch of child^.right  */
          if (child->right != NULL)
            {
              /* Scan for left most node of child^.right  */
              i = child->right;
              while (i->left != NULL)
                {
                  i = i->left;
                }
              i->left = child->left;
              parent->left = child->right;
            }
          else
            {
              /* (as in a single linked list) to child^.left.  */
              parent->left = child->left;
            }
          libc_free ((void *) child);
        }
    }
  else
    {
      M2RTS_Halt ((char *) "/home/gaius/GM2/graft-combine/gm2-floppsie/gcc/m2/gm2-libs-iso/RTentity.mod", 75, 220, (char *) "DelKey", 6, (char *) "internal runtime error, trying to delete an entity which is not in the tree", 75);
    }
  RTco_signal (mutex);
}

unsigned int RTentity_IsIn (RTentity_Group g, void * a)
{
  RTentity_Group child;
  RTentity_Group parent;

  RTco_wait (mutex);
  findChildAndParent (g, a, &child, &parent);
  RTco_signal (mutex);
  return child != NULL;
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}

void _M2_RTentity_init (__attribute__((unused)) int argc, __attribute__((unused)) char *argv[])
{
  initialized = FALSE;
}

void _M2_RTentity_finish (__attribute__((unused)) int argc, __attribute__((unused)) char *argv[])
{
}
