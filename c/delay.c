/* do not edit automatically generated by mc from delay.  */
/* This file is part of GNU Modula-2.

GNU Modula-2 is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GNU Modula-2 is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with gm2; see the file COPYING.  If not, write to the Free Software
Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */

#   if !defined (PROC_D)
#      define PROC_D
       typedef void (*PROC_t) (void);
       typedef struct { PROC_t proc; } PROC;
#   endif

#   if !defined (TRUE)
#      define TRUE (1==1)
#   endif

#   if !defined (FALSE)
#      define FALSE (1==0)
#   endif

#define _delay_H
#define _delay_C

#   include "GSelective.h"
#   include "GM2RTS.h"

#   define M 1000000
#   define debugDelay 0
static unsigned int noDelay;
static Selective_Timeval delayT;
static unsigned int sec;
static unsigned int usec;
static unsigned int firstSec;
static unsigned int actualFps;
static unsigned int totalFrames;

/*
   nextFrameTime - calculates the time of the next frame, given the frames
                   per second.  This should be called once for every frame.
*/

void delay_nextFrameTime (unsigned int fps);

/*
   wait - waits until 
*/

void delay_wait (void);

/*
   getActualFPS - return the actual frames per second.
*/

unsigned int delay_getActualFPS (void);

/*
   isEarlier - 
*/

static unsigned int isEarlier (unsigned int s1, unsigned int u1, unsigned int s2, unsigned int u2);


/*
   isEarlier - 
*/

static unsigned int isEarlier (unsigned int s1, unsigned int u1, unsigned int s2, unsigned int u2)
{
  if (s1 < s2)
    {
      return TRUE;
    }
  else if (s1 > s2)
    {
      /* avoid dangling else.  */
      return FALSE;
    }
  else
    {
      /* avoid dangling else.  */
      return u1 < u2;
    }
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   nextFrameTime - calculates the time of the next frame, given the frames
                   per second.  This should be called once for every frame.
*/

void delay_nextFrameTime (unsigned int fps)
{
  unsigned int dt;

  totalFrames += 1;
  if (fps == 0)
    {
      noDelay = TRUE;
    }
  else
    {
      if ((Selective_GetTimeOfDay (delayT)) == 0)
        {}  /* empty.  */
      Selective_GetTime (delayT, &sec, &usec);
      if (firstSec == 0)
        {
          firstSec = sec;
          actualFps = fps;
        }
      else if (firstSec < sec)
        {
          /* avoid dangling else.  */
          actualFps = totalFrames / (sec-firstSec);
        }
      dt = M / fps;
      usec += dt;
      if (usec > M)
        {
          usec -= M;
          sec += 1;
        }
      sec += debugDelay;
    }
}


/*
   wait - waits until 
*/

void delay_wait (void)
{
  Selective_SetOfFd r;
  Selective_SetOfFd w;
  Selective_SetOfFd e;
  unsigned int u;
  unsigned int s;

  if (! noDelay)
    {
      if ((Selective_GetTimeOfDay (delayT)) == 0)
        {}  /* empty.  */
      Selective_GetTime (delayT, &s, &u);
      if (isEarlier (s, u, sec, usec))
        {
          sec -= s;
          if (usec < u)
            {
              usec = (M+usec)-u;
              if (sec > 0)
                {
                  sec -= 1;
                }
              else
                {
                  M2RTS_HALT (-1);  /* algorithmic error..  */
                  __builtin_unreachable ();
                }
            }
          else
            {
              usec -= u;
            }
          Selective_SetTime (delayT, sec, usec);
          r = Selective_InitSet ();
          w = Selective_InitSet ();
          e = Selective_InitSet ();
          Selective_FdZero (r);
          if ((Selective_Select (0, r, w, e, delayT)) == 0)
            {}  /* empty.  */
          /* do nothing  */
          r = Selective_KillSet (r);
          w = Selective_KillSet (w);
          e = Selective_KillSet (e);
        }
    }
}


/*
   getActualFPS - return the actual frames per second.
*/

unsigned int delay_getActualFPS (void)
{
  return actualFps;
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}

void _M2_delay_init (__attribute__((unused)) int argc, __attribute__((unused)) char *argv[])
{
  delayT = Selective_InitTime (0, 0);
  firstSec = 0;
  totalFrames = 0;
}

void _M2_delay_finish (__attribute__((unused)) int argc, __attribute__((unused)) char *argv[])
{
}
