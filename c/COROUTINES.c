/* do not edit automatically generated by mc from COROUTINES.  */
/* COROUTINES.mod implement the ISO COROUTINES specification.

Copyright (C) 2002-2020 Free Software Foundation, Inc.
Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.

This file is part of GNU Modula-2.

GNU Modula-2 is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GNU Modula-2 is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

#   if !defined (PROC_D)
#      define PROC_D
       typedef void (*PROC_t) (void);
       typedef struct { PROC_t proc; } PROC;
#   endif

#   if !defined (TRUE)
#      define TRUE (1==1)
#   endif

#   if !defined (FALSE)
#      define FALSE (1==0)
#   endif

#include <stddef.h>
#   include "GStorage.h"
#define _COROUTINES_H
#define _COROUTINES_C

#   include "GRTco.h"
#   include "GRTExceptions.h"
#   include "GSYSTEM.h"
#   include "GEXCEPTIONS.h"
#   include "GRTint.h"
#   include "GStorage.h"
#   include "GAssertion.h"
#   include "GM2RTS.h"
#   include "Glibc.h"
#   include "GProcesses.h"

#   define COROUTINES_UnassignedPriority 0
typedef unsigned int COROUTINES_INTERRUPTSOURCE;

typedef unsigned int COROUTINES_PROTECTION;

#   define MinStack ((16*1024)*1024)
#   define Debugging FALSE
typedef struct _T1_r _T1;

typedef _T1 *COROUTINES_COROUTINE;

typedef struct _T2_r _T2;

typedef _T2 *SourceList;

typedef enum {suspended, ready, new, running} Status;

struct _T1_r {
               int context;
               RTExceptions_EHBlock ehblock;
               unsigned int inexcept;
               EXCEPTIONS_ExceptionSource source;
               void *wspace;
               unsigned int nLocs;
               Status status;
               SourceList attached;
               COROUTINES_COROUTINE next;
             };

struct _T2_r {
               SourceList next;
               COROUTINES_INTERRUPTSOURCE vec;
               COROUTINES_COROUTINE curco;
               SourceList chain;
               COROUTINES_COROUTINE *ptrToTo;
               COROUTINES_COROUTINE *ptrToFrom;
             };

static SourceList freeList;
static COROUTINES_COROUTINE head;
static COROUTINES_COROUTINE previous;
static COROUTINES_COROUTINE currentCoRoutine;
static void * illegalFinish;
static unsigned int initMain;
static unsigned int initCo;
static int lock;
void COROUTINES_NEWCOROUTINE (PROC procBody, void * workspace, unsigned int size, COROUTINES_COROUTINE *cr, COROUTINES_PROTECTION initProtection);
void COROUTINES_TRANSFER (COROUTINES_COROUTINE *from, COROUTINES_COROUTINE to);

/*
   localInit - checks to see whether we need to initialize libpth.
*/

void COROUTINES_IOTRANSFER (COROUTINES_COROUTINE *from, COROUTINES_COROUTINE to);

/*
   Dispose - returns, l, to the freeList.
*/

void COROUTINES_ATTACH (COROUTINES_INTERRUPTSOURCE source);
void COROUTINES_DETACH (COROUTINES_INTERRUPTSOURCE source);

/*
   getAttached - returns the first COROUTINE associated with, source.
                 It returns NIL is no COROUTINE is associated with, source.
*/

unsigned int COROUTINES_IsATTACHED (COROUTINES_INTERRUPTSOURCE source);
COROUTINES_COROUTINE COROUTINES_HANDLER (COROUTINES_INTERRUPTSOURCE source);
COROUTINES_COROUTINE COROUTINES_CURRENT (void);
void COROUTINES_LISTEN (COROUTINES_PROTECTION p);
COROUTINES_PROTECTION COROUTINES_PROT (void);

/*
   TurnInterrupts - switches processor interrupts to the protection
                    level, to.  It returns the old value.
*/

COROUTINES_PROTECTION COROUTINES_TurnInterrupts (COROUTINES_PROTECTION to);

/*
   ListenLoop - should be called instead of users writing:

                LOOP
                   LISTEN
                END

                It performs the same function but yields
                control back to the underlying operating system.
                It also checks for deadlock.
                This function returns when an interrupt occurs.
                (File descriptor becomes ready or time event expires).
*/

void COROUTINES_ListenLoop (void);

/*
   Transfer -
*/

static void Transfer (COROUTINES_COROUTINE *from, COROUTINES_COROUTINE to);

/*
   localMain - creates the holder for the main process.
*/

static void localMain (void);

/*
   localInit - checks to see whether we need to initialize libpth.
*/

static void localInit (void);

/*
   New - assigns, l, to a new SourceList.
*/

static void New (SourceList *l);

/*
   Dispose - returns, l, to the freeList.
*/

static void Dispose (SourceList l);

/*
   getAttached - returns the first COROUTINE associated with, source.
                 It returns NIL is no COROUTINE is associated with, source.
*/

static COROUTINES_COROUTINE getAttached (COROUTINES_INTERRUPTSOURCE source);

/*
   removeAttached - removes all sources of interrupt from COROUTINE, c.
*/

static void removeAttached (COROUTINES_COROUTINE c);

/*
   IOTransferHandler - handles interrupts related to a pending IOTRANSFER.
*/

static void IOTransferHandler (unsigned int InterruptNo, unsigned int Priority, SourceList l);

/*
   Init -
*/

static void Init (void);


/*
   Transfer -
*/

static void Transfer (COROUTINES_COROUTINE *from, COROUTINES_COROUTINE to)
{
  if (Debugging)
    {
      libc_printf ((char *) "TRANSFER\\n", 10);
      libc_printf ((char *) "current coroutine is: %d\\n", 26, currentCoRoutine->context);
      if (previous != NULL)
        {
          libc_printf ((char *) "previous coroutine is: %d\\n", 27, previous->context);
        }
      libc_printf ((char *) "wishes to context switch to: %d\\n", 33, to->context);
    }
  previous = currentCoRoutine;
  (*from) = currentCoRoutine;
  if (to->context == (*from)->context)
    {
      M2RTS_Halt ((char *) "/home/gaius/GM2/graft-combine/gm2-floppsie/gcc/m2/gm2-libs-iso/COROUTINES.mod", 77, 173, (char *) "Transfer", 8, (char *) "error when attempting to context switch to the same process", 59);
    }
  (*from)->inexcept = RTExceptions_SetExceptionState (to->inexcept);
  (*from)->source = RTExceptions_GetExceptionSource ();
  currentCoRoutine = to;
  RTExceptions_SetExceptionBlock (currentCoRoutine->ehblock);
  RTExceptions_SetExceptionSource ((void *) currentCoRoutine->source);
  RTco_transfer (&(*from)->context, to->context);
}


/*
   localMain - creates the holder for the main process.
*/

static void localMain (void)
{
  COROUTINES_PROTECTION old;

  if (! initMain)
    {
      initMain = TRUE;
      lock = RTco_initSemaphore (1);
      RTco_wait (lock);
      Storage_ALLOCATE ((void **) &currentCoRoutine, sizeof (_T1));
      currentCoRoutine->context = RTco_currentThread ();
      currentCoRoutine->ehblock = RTExceptions_GetExceptionBlock ();
      currentCoRoutine->inexcept = RTExceptions_IsInExceptionState ();
      currentCoRoutine->source = RTExceptions_GetExceptionSource ();
      currentCoRoutine->wspace = NULL;
      currentCoRoutine->nLocs = 0;
      currentCoRoutine->status = running;
      currentCoRoutine->attached = NULL;
      currentCoRoutine->next = head;
      head = currentCoRoutine;
      old = RTco_turnInterrupts ((unsigned int) 7);  /* was UnassignedPriority  */
      RTco_signal (lock);  /* was UnassignedPriority  */
    }
}


/*
   localInit - checks to see whether we need to initialize libpth.
*/

static void localInit (void)
{
  if (! initCo)
    {
      if ((RTco_init ()) != 0)
        {
          M2RTS_Halt ((char *) "/home/gaius/GM2/graft-combine/gm2-floppsie/gcc/m2/gm2-libs-iso/COROUTINES.mod", 77, 227, (char *) "localInit", 9, (char *) "failed to initialize RTco", 25);
        }
      RTint_Init ();
      initCo = TRUE;
    }
  localMain ();
}


/*
   New - assigns, l, to a new SourceList.
*/

static void New (SourceList *l)
{
  if (freeList == NULL)
    {
      Storage_ALLOCATE ((void **) &(*l), sizeof (_T2));
    }
  else
    {
      (*l) = freeList;
      freeList = freeList->next;
    }
}


/*
   Dispose - returns, l, to the freeList.
*/

static void Dispose (SourceList l)
{
  l->next = freeList;
  freeList = l;
}


/*
   getAttached - returns the first COROUTINE associated with, source.
                 It returns NIL is no COROUTINE is associated with, source.
*/

static COROUTINES_COROUTINE getAttached (COROUTINES_INTERRUPTSOURCE source)
{
  SourceList l;
  COROUTINES_COROUTINE c;

  localInit ();
  c = head;
  while (c != NULL)
    {
      l = c->attached;
      while (l != NULL)
        {
          if (l->vec == source)
            {
              return c;
            }
          else
            {
              l = l->next;
            }
        }
      c = c->next;
    }
  return NULL;
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   removeAttached - removes all sources of interrupt from COROUTINE, c.
*/

static void removeAttached (COROUTINES_COROUTINE c)
{
  SourceList l;

  localInit ();
  l = c->attached;
  while (l != NULL)
    {
      RTint_ExcludeVector ((unsigned int) l->vec);
      l = l->next;
    }
}


/*
   IOTransferHandler - handles interrupts related to a pending IOTRANSFER.
*/

static void IOTransferHandler (unsigned int InterruptNo, unsigned int Priority, SourceList l)
{
  SourceList ourself;

  if (Debugging)
    {
      libc_printf ((char *) "IOTransferHandler called\\n", 26);
      Processes_displayProcesses ((char *) "IOTransferHandler", 17);
      libc_printf ((char *) "IOTransferHandler vec %d coroutine: %d\\n", 40, l->vec, l->curco->context);
      libc_printf ((char *) "localInit\\n", 11);
    }
  localInit ();
  if (l == NULL)
    {
      M2RTS_Halt ((char *) "/home/gaius/GM2/graft-combine/gm2-floppsie/gcc/m2/gm2-libs-iso/COROUTINES.mod", 77, 513, (char *) "IOTransferHandler", 17, (char *) "no coroutine attached to this interrupt vector which was initiated by IOTRANSFER", 80);
    }
  else
    {
      if (Debugging)
        {
          libc_printf ((char *) "IOTransferHandler called\\n", 26);
          libc_printf ((char *) "before wait (lock)\\n", 20);
        }
      RTco_wait (lock);
      if (Debugging)
        {
          libc_printf ((char *) "IOTransferHandler vec %d coroutine 0x%x\\n", 41, l->vec, l->curco);
          libc_printf ((char *) "current coroutine is: %d\\n", 26, currentCoRoutine->context);
          if (previous != NULL)
            {
              libc_printf ((char *) "previous coroutine is: %d\\n", 27, previous->context);
            }
          libc_printf ((char *) "handler wants to context switch to:  %d\\n", 41, l->curco->context);
          Processes_displayProcesses ((char *) "IOTransferHandler", 17);
        }
      /* 
         ourself := AttachVector (InterruptNo, chain) ;
         IF ourself # l
         THEN
            Halt (__FILE__, __LINE__, __FUNCTION__,
                  'inconsistancy of return result')
         END ;
         IF chain = NIL
         THEN
            removeAttached (curco)
         ELSE
            printf ('odd vector has been chained
      ')
         END ;
  */
      removeAttached (l->curco);  /* remove all sources of interrupt for l^.curco.  */
      (*l->ptrToFrom) = currentCoRoutine;  /* remove all sources of interrupt for l^.curco.  */
      previous = currentCoRoutine;
      previous->inexcept = RTExceptions_SetExceptionState (l->curco->inexcept);
      previous->source = RTExceptions_GetExceptionSource ();
      currentCoRoutine = l->curco;
      RTExceptions_SetExceptionBlock (currentCoRoutine->ehblock);
      RTExceptions_SetExceptionSource ((void *) currentCoRoutine->source);
      RTco_signal (lock);
      RTco_transfer (&previous->context, currentCoRoutine->context);
    }
}


/*
   Init -
*/

static void Init (void)
{
  freeList = NULL;
  initCo = FALSE;
  initMain = FALSE;
  currentCoRoutine = NULL;
}

void COROUTINES_NEWCOROUTINE (PROC procBody, void * workspace, unsigned int size, COROUTINES_COROUTINE *cr, COROUTINES_PROTECTION initProtection)
{
  int tp;
  COROUTINES_PROTECTION old;

  /* Creates a new coroutine whose body is given by procBody, and
     returns the identity of the coroutine in cr. workspace is a
     pointer to the work space allocated to the coroutine; size
     specifies the size of this workspace in terms of SYSTEM.LOC.

     The optarg, initProtection, may contain a single parameter
     which specifies the initial protection level of the coroutine.
  */
  localInit ();
  old = COROUTINES_TurnInterrupts (7);
  if (initProtection == COROUTINES_UnassignedPriority)
    {
      initProtection = COROUTINES_PROT ();
    }
  tp = RTco_initThread (procBody, size, (unsigned int) initProtection);
  if (tp == -1)
    {
      M2RTS_Halt ((char *) "/home/gaius/GM2/graft-combine/gm2-floppsie/gcc/m2/gm2-libs-iso/COROUTINES.mod", 77, 118, (char *) "NEWCOROUTINE", 12, (char *) "unable to create a new thread", 29);
    }
  Storage_ALLOCATE ((void **) &(*cr), sizeof (_T1));
  (*cr)->context = tp;
  (*cr)->ehblock = RTExceptions_InitExceptionBlock ();
  (*cr)->inexcept = FALSE;
  (*cr)->source = NULL;
  (*cr)->wspace = workspace;
  (*cr)->nLocs = size;
  (*cr)->status = new;
  (*cr)->attached = NULL;
  (*cr)->next = head;
  head = (*cr);
  old = COROUTINES_TurnInterrupts (old);
}

void COROUTINES_TRANSFER (COROUTINES_COROUTINE *from, COROUTINES_COROUTINE to)
{
  COROUTINES_PROTECTION old;

  /* Returns the identity of the calling coroutine in from, and
     transfers control to the coroutine specified by to.
  */
  localInit ();
  old = COROUTINES_TurnInterrupts (7);
  /* wait (lock) ;  */
  Transfer (from, to);
  /* signal (lock) ;  */
  old = COROUTINES_TurnInterrupts (old);
}


/*
   localInit - checks to see whether we need to initialize libpth.
*/

void COROUTINES_IOTRANSFER (COROUTINES_COROUTINE *from, COROUTINES_COROUTINE to)
{
  SourceList prev;
  SourceList l;
  COROUTINES_PROTECTION old;

  /* Returns the identity of the calling coroutine in from and
     transfers control to the coroutine specified by to.  On
     occurrence of an interrupt, associated with the caller, control
     is transferred back to the caller, and the identity of the
     interrupted coroutine is returned in from.  The calling coroutine
     must be associated with a source of interrupts.
  */
  localInit ();
  old = COROUTINES_TurnInterrupts (7);
  if ((*from) == to)
    {
      M2RTS_Halt ((char *) "/home/gaius/GM2/graft-combine/gm2-floppsie/gcc/m2/gm2-libs-iso/COROUTINES.mod", 77, 254, (char *) "IOTRANSFER", 10, (char *) "error IOTRANSFER cannot transfer control to the running COROUTINE", 65);
    }
  RTco_wait (lock);
  l = currentCoRoutine->attached;
  if (l == NULL)
    {
      libc_printf ((char *) "no source of interrupts associated with coroutine\\n", 51);
    }
  while (l != NULL)
    {
      l->ptrToFrom = from;
      l->ptrToTo = &to;
      l->curco = currentCoRoutine;
      Assertion_Assert (currentCoRoutine != NULL);
      prev = RTint_AttachVector ((unsigned int) l->vec, (void *) l);
      Assertion_Assert ((*from) != to);
      if ((prev != NULL) && (prev != l))
        {
          libc_printf ((char *) "not expecting multiple COROUTINES to be waiting on a single interrupt source\\n", 78);
        }
      RTint_IncludeVector ((unsigned int) l->vec);
      l = l->next;
    }
  RTco_signal (lock);
  Transfer (from, to);
  (*from) = previous;
  old = COROUTINES_TurnInterrupts (old);
}


/*
   Dispose - returns, l, to the freeList.
*/

void COROUTINES_ATTACH (COROUTINES_INTERRUPTSOURCE source)
{
  SourceList l;

  /* Associates the specified source of interrupts with the calling
     coroutine.  */
  localInit ();
  RTco_wait (lock);
  l = currentCoRoutine->attached;
  while (l != NULL)
    {
      if (l->vec == source)
        {
          l->curco = currentCoRoutine;
          RTco_signal (lock);
          return;
        }
      else
        {
          l = l->next;
        }
    }
  New (&l);
  l->next = currentCoRoutine->attached;
  l->vec = source;
  l->curco = currentCoRoutine;
  l->chain = NULL;
  currentCoRoutine->attached = l;
  if ((RTint_AttachVector ((unsigned int) source, (void *) l)) != NULL)
    {
      libc_printf ((char *) "ATTACH implementation restriction only one coroutine may be attached to a specific interrupt source\\n", 101);
    }
  RTco_signal (lock);
}

void COROUTINES_DETACH (COROUTINES_INTERRUPTSOURCE source)
{
  SourceList l;
  SourceList prev;

  /* Dissociates the specified source of interrupts from the calling
     coroutine.  */
  localInit ();
  RTco_wait (lock);
  l = currentCoRoutine->attached;
  prev = NULL;
  while (l != NULL)
    {
      if (l->vec == source)
        {
          if (prev == NULL)
            {
              Assertion_Assert (l == currentCoRoutine->attached);
              currentCoRoutine->attached = currentCoRoutine->attached->next;
            }
          else
            {
              prev->next = l->next;
            }
          Dispose (l);
          RTco_signal (lock);
          return;
        }
      else
        {
          prev = l;
          l = l->next;
        }
    }
  RTco_signal (lock);
}


/*
   getAttached - returns the first COROUTINE associated with, source.
                 It returns NIL is no COROUTINE is associated with, source.
*/

unsigned int COROUTINES_IsATTACHED (COROUTINES_INTERRUPTSOURCE source)
{
  unsigned int result;

  /* Returns TRUE if and only if the specified source of interrupts is
     currently associated with a coroutine; otherwise returns FALSE.
  */
  localInit ();
  RTco_wait (lock);
  result = (getAttached (source)) != NULL;
  RTco_signal (lock);
  return result;
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}

COROUTINES_COROUTINE COROUTINES_HANDLER (COROUTINES_INTERRUPTSOURCE source)
{
  COROUTINES_COROUTINE co;

  /* Returns the coroutine, if any, that is associated with the source
     of interrupts. The result is undefined if IsATTACHED(source) =
     FALSE.
  */
  localInit ();
  RTco_wait (lock);
  co = getAttached (source);
  RTco_signal (lock);
  return co;
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}

COROUTINES_COROUTINE COROUTINES_CURRENT (void)
{
  /* Returns the identity of the calling coroutine.  */
  localInit ();
  return currentCoRoutine;
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}

void COROUTINES_LISTEN (COROUTINES_PROTECTION p)
{
  /* Momentarily changes the protection of the calling coroutine to p.  */
  localInit ();
  RTint_Listen (FALSE, (RTint_DispatchVector) {(RTint_DispatchVector_t) IOTransferHandler}, (unsigned int) p);
}

COROUTINES_PROTECTION COROUTINES_PROT (void)
{
  /* Returns the protection of the calling coroutine.  */
  localInit ();
  return RTco_currentInterruptLevel ();
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   TurnInterrupts - switches processor interrupts to the protection
                    level, to.  It returns the old value.
*/

COROUTINES_PROTECTION COROUTINES_TurnInterrupts (COROUTINES_PROTECTION to)
{
  COROUTINES_PROTECTION old;

  localInit ();
  old = RTco_turnInterrupts ((unsigned int) to);
  RTint_Listen (FALSE, (RTint_DispatchVector) {(RTint_DispatchVector_t) IOTransferHandler}, (unsigned int) to);
  return old;
  /* static analysis guarentees a RETURN statement will be used before here.  */
  __builtin_unreachable ();
}


/*
   ListenLoop - should be called instead of users writing:

                LOOP
                   LISTEN
                END

                It performs the same function but yields
                control back to the underlying operating system.
                It also checks for deadlock.
                This function returns when an interrupt occurs.
                (File descriptor becomes ready or time event expires).
*/

void COROUTINES_ListenLoop (void)
{
  localInit ();
  RTint_Listen (TRUE, (RTint_DispatchVector) {(RTint_DispatchVector_t) IOTransferHandler}, (unsigned int) COROUTINES_UnassignedPriority);
}

void _M2_COROUTINES_init (__attribute__((unused)) int argc, __attribute__((unused)) char *argv[])
{
  Init ();
}

void _M2_COROUTINES_finish (__attribute__((unused)) int argc, __attribute__((unused)) char *argv[])
{
}
